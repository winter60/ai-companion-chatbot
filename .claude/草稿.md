我正在开发一个AI对话机器人，并已集成Google登录功能。

现在，我希望实现一个用户访问限制的功能：未登录的用户每天可以进行3次对话，而登录的用户每天可以刷新10次对话次数。


虽然我计划未来推出付费功能（例如，免费用户每天10次，基础版100次，高阶版1000次），但目前只想专注于实现免费版的功能。

为了在Next.js和Supabase中实现要一需求，包括用户身份验证、对话次数的管理以及如何设置每日刷新机制。

我打算这样来实现：

### 第1步：在 Supabase 中创建数据库函数

我们将创建一个名为 `increment_conversation_and_check_limit` 的函数。这个函数会处理已登录用户的所有逻辑。

你可以在 Supabase 控制台的 `SQL Editor` -\> `New query` 中运行以下代码：

```sql
-- 定义函数返回的类型，方便前端处理
CREATE TYPE public.usage_status AS (
  success boolean,
  message text,
  remaining_count integer
);

-- 创建核心的 RPC 函数
CREATE OR REPLACE FUNCTION public.increment_conversation_and_check_limit()
RETURNS public.usage_status
LANGUAGE plpgsql
SECURITY DEFINER -- 非常重要：使用定义者的权限运行，可以绕过RLS进行内部逻辑处理
AS $$
DECLARE
  current_user_id uuid;
  profile_record record;
  today_date date;
  user_limit integer := 10; -- 登录用户的限制
  new_count integer;
BEGIN
  -- 1. 获取当前调用此函数的认证用户的 ID
  current_user_id := auth.uid();
  IF current_user_id IS NULL THEN
    RETURN (false, '用户未认证', 0)::public.usage_status;
  END IF;

  -- 2. 获取今天的日期
  today_date := current_date;

  -- 3. 查询用户的 profile 记录
  SELECT * INTO profile_record FROM public.profiles WHERE id = current_user_id;
  
  -- 如果用户是新注册的，profile 可能还未创建，处理这种情况
  IF profile_record IS NULL THEN
    INSERT INTO public.profiles(id, conversation_count, last_conversation_date)
    VALUES (current_user_id, 1, today_date);
    RETURN (true, '操作成功', user_limit - 1)::public.usage_status;
  END IF;

  -- 4. 每日重置逻辑：如果上次对话不是今天，则重置计数
  IF profile_record.last_conversation_date < today_date THEN
    profile_record.conversation_count := 0;
  END IF;

  -- 5. 检查次数是否已达上限
  IF profile_record.conversation_count >= user_limit THEN
    RETURN (false, '今日对话次数已用完', 0)::public.usage_status;
  END IF;

  -- 6. 更新数据库：次数+1，并更新日期
  new_count := profile_record.conversation_count + 1;
  UPDATE public.profiles
  SET
    conversation_count = new_count,
    last_conversation_date = today_date,
    updated_at = now()
  WHERE id = current_user_id;

  -- 7. 返回成功状态和剩余次数
  RETURN (true, '操作成功', user_limit - new_count)::public.usage_status;

EXCEPTION
  -- 异常处理
  WHEN OTHERS THEN
    RETURN (false, '服务器内部错误', 0)::public.usage_status;
END;
$$;
```

**关键点解释**：

  * `SECURITY DEFINER`：这使得函数在执行时拥有创建者（通常是`postgres`超级用户）的权限。这样做的好处是函数内部逻辑可以暂时无视 RLS 规则去 `SELECT` 和 `UPDATE` 数据，因为我们的函数逻辑本身已经通过 `auth.uid()` 保证了只操作当前用户的数据，所以是安全的。
  * `RETURNS public.usage_status`：我们定义了一个自定义的返回类型 `usage_status`，这样在调用 RPC 后能得到一个结构清晰的对象，包含了成功/失败状态、消息和剩余次数。
  * **原子性**：整个 `BEGIN...END;` 块是一个事务。如果在 `UPDATE` 步骤失败，整个操作都会回滚，不会出现次数检查通过了但扣减失败的情况。

-----

### 第2步：重构 Next.js API 路由

现在，你的 Next.js API 路由会变得极其简单和清晰。它不再需要执行任何业务逻辑，只需要作为一个安全的代理来调用 Supabase 的 RPC 函数。

`app/api/chat/route.ts` 的代码现在是这样：

```typescript
// app/api/chat/route.ts (App Router 示例)
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });

  // 1. 检查用户是否登录
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    // 如果需要处理访客，在这里添加访客RPC调用逻辑
    return NextResponse.json({ error: '请登录后使用' }, { status: 401 });
  }

  // 2. 调用数据库函数来处理所有逻辑
  const { data, error } = await supabase.rpc('increment_conversation_and_check_limit');

  if (error) {
    console.error('RPC Error:', error);
    return NextResponse.json({ error: '服务器内部错误' }, { status: 500 });
  }

  // 3. 根据函数的返回结果，响应前端
  const { success, message, remaining_count } = data;

  if (!success) {
    // 次数用尽或发生其他错误
    return NextResponse.json({ 
      error: message, 
      limitReached: true 
    }, { status: 429 }); // 429: Too Many Requests
  }

  // 4. 如果成功，代表次数已扣减，现在可以安全地执行AI对话
  // const { prompt } = await req.json();
  // const aiResponse = await callMyAiModel(prompt);

  // 5. 返回AI结果和剩余次数
  return NextResponse.json({ 
    // data: aiResponse, 
    remaining: remaining_count 
  });
}
```

看，现在的 API 路由变得多么“薄”！它的职责非常单一：验证身份、调用RPC、根据RPC结果返回响应。所有的核心逻辑都封装在了 Supabase 中。

-----

### 第3步：如何处理访客 (Guest Users)？

同样地，你也可以为访客创建一个 RPC 函数。

1.  **创建 `increment_guest_conversation` 函数**:

    ```sql
    CREATE OR REPLACE FUNCTION public.increment_guest_conversation(request_ip text)
    RETURNS public.usage_status
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
    DECLARE
      guest_record record;
      today_date date;
      guest_limit integer := 3;
      new_count integer;
    BEGIN
      today_date := current_date;

      SELECT * INTO guest_record FROM public.guest_usage WHERE ip_address = request_ip;
      
      IF guest_record IS NULL THEN
        INSERT INTO public.guest_usage(ip_address, conversation_count, last_conversation_date)
        VALUES (request_ip, 1, today_date);
        RETURN (true, '操作成功', guest_limit - 1)::public.usage_status;
      END IF;

      IF guest_record.last_conversation_date < today_date THEN
        guest_record.conversation_count := 0;
      END IF;

      IF guest_record.conversation_count >= guest_limit THEN
        RETURN (false, '访客试用次数已用完，请登录后继续', 0)::public.usage_status;
      END IF;

      new_count := guest_record.conversation_count + 1;
      UPDATE public.guest_usage
      SET
        conversation_count = new_count,
        last_conversation_date = today_date
      WHERE ip_address = request_ip;
      
      RETURN (true, '操作成功', guest_limit - new_count)::public.usage_status;
    END;
    $$;
    ```

2.  **在 API 路由中调用它**:

    ```typescript
    // ... 在 app/api/chat/route.ts 中
    import { headers } from 'next/headers';

    if (!session) {
        const ip = headers().get('x-forwarded-for'); // 获取IP
        if (!ip) {
            return NextResponse.json({ error: '无法识别请求来源' }, { status: 400 });
        }

        const { data, error } = await supabase.rpc('increment_guest_conversation', { request_ip: ip });
        
        // ... 后续逻辑与登录用户类似
    }
    // ...
    ```
